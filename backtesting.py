"""
This is main module for strategy backtesting

Algorithm: SMA(1000) Momentum Crossover on VN30F1M
- Buy signal:  previous tick < SMA(1000) AND current tick >= SMA(1000)  → Limit Buy at ceiling price
- Sell signal: previous tick > SMA(1000) AND current tick <= SMA(1000)  → Limit Sell at floor price
- Take-Profit: unrealized P&L >= +3 points
- Stop-Loss:   unrealized P&L <= -1 point
- Position size: 1 contract at all times
- Overnight rule: force-close any open position at ATC (end of day)
"""

import numpy as np
from datetime import timedelta
from decimal import Decimal, ROUND_HALF_UP
from typing import List, Optional
from collections import deque
import pandas as pd
import matplotlib.pyplot as plt

from config.config import BACKTESTING_CONFIG
from metrics.metric import get_returns, Metric
from utils import get_expired_dates, from_cash_to_tradeable_contracts, round_decimal

FEE_PER_CONTRACT = Decimal(BACKTESTING_CONFIG["fee"]) * Decimal('100')

# ---------- Strategy constants ----------
SMA_WINDOW   = 1000          # number of ticks for the moving average
TP_POINTS    = Decimal('3')  # take-profit threshold in index points
SL_POINTS    = Decimal('2')  # stop-loss threshold in index points (magnitude)
MULTIPLIER   = Decimal('100')  # VND per index point per contract


class Backtesting:
    """
    Backtesting class — SMA(1000) Momentum Crossover strategy.

    Rules (per the CS408 algorithm spec):
    - Signal generated by SMA(1000) of tick prices.
    - Buy  when prev_tick < SMA and cur_tick >= SMA  → Limit Buy  at ceiling (+1 tick).
    - Sell when prev_tick > SMA and cur_tick <= SMA  → Limit Sell at floor   (-1 tick).
    - Position size: exactly 1 contract long or 1 contract short.
    - Take-Profit at +3 points unrealised P&L (per contract × multiplier).
    - Stop-Loss   at -1 point  unrealised P&L (per contract × multiplier).
    - End-of-day: any open position is force-closed at the daily closing price (ATC rule).
    """

    def __init__(
        self,
        capital: Decimal,
        printable=True,
    ):
        self.printable = printable
        self.metric = None

        # --- position state ---
        self.inventory: int = 0          # +1 = long 1 contract, -1 = short 1 contract
        self.entry_price: Optional[Decimal] = None  # price at which we entered

        # --- P&L / NAV tracking ---
        self.realised_pnl: Decimal = Decimal('0')   # cumulative realised P&L within the day
        self.daily_assets: List[Decimal] = [capital]
        self.daily_returns: List[Decimal] = []
        self.tracking_dates: list = []
        self.daily_inventory: list = []
        self.monthly_tracking: list = []

        # --- SMA(1000) rolling window ---
        self._price_window: deque = deque(maxlen=SMA_WINDOW)
        self._prev_price: Optional[Decimal] = None   # last tick price (for crossover detection)
        self._prev_sma: Optional[Decimal] = None     # SMA value at the previous tick

        # --- roll-over F1→F2 support (kept for process_data compatibility) ---
        self.old_timestamp = None

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _current_sma(self) -> Optional[Decimal]:
        """Return SMA(1000) if enough data, else None."""
        if len(self._price_window) < SMA_WINDOW:
            return None
        return sum(self._price_window) / Decimal(SMA_WINDOW)

    def _unrealised_pnl(self, cur_price: Decimal) -> Decimal:
        """Unrealised P&L for the open position (in VND)."""
        if self.inventory == 0 or self.entry_price is None:
            return Decimal('0')
        direction = Decimal('1') if self.inventory > 0 else Decimal('-1')
        return direction * (cur_price - self.entry_price) * MULTIPLIER

    def _open_position(self, direction: int, price: Decimal):
        """Open a new 1-contract position."""
        self.inventory = direction
        self.entry_price = price

    def _close_position(self, price: Decimal):
        """Close the current position and book the realised P&L (net of fees)."""
        if self.inventory == 0:
            return
        direction = Decimal('1') if self.inventory > 0 else Decimal('-1')
        gross = direction * (price - self.entry_price) * MULTIPLIER
        self.realised_pnl += gross - FEE_PER_CONTRACT   # one fee per close trade
        self.inventory = 0
        self.entry_price = None

    # ------------------------------------------------------------------
    # Daily P&L snapshot (called at end-of-day)
    # ------------------------------------------------------------------

    def _update_pnl(self, close_price: Decimal):
        """
        Book today's P&L into daily_assets.
        Any open position is force-closed at the daily closing price (overnight rule).
        """
        self._close_position(close_price)   # overnight rule: close at ATC price

        cur_asset = self.daily_assets[-1]
        new_asset = cur_asset + self.realised_pnl
        self.realised_pnl = Decimal('0')    # reset for next day

        daily_return = new_asset / cur_asset - Decimal('1')
        self.daily_returns.append(daily_return)
        self.daily_assets.append(new_asset)

    # ------------------------------------------------------------------
    # Data processing (unchanged from original — keeps F1/F2 merge logic)
    # ------------------------------------------------------------------

    @staticmethod
    def process_data(evaluation=False):
        prefix_path = "data/os/" if evaluation else "data/is/"
        f1_data = pd.read_csv(f"{prefix_path}VN30F1M_data.csv")
        f1_data["datetime"] = pd.to_datetime(
            f1_data["datetime"], format="%Y-%m-%d %H:%M:%S.%f"
        )
        f1_data["date"] = (
            pd.to_datetime(f1_data["date"], format="%Y-%m-%d").copy().dt.date
        )
        rounding_columns = ["close", "price", "best-bid", "best-ask", "spread"]
        for col in rounding_columns:
            f1_data = round_decimal(f1_data, col)

        f2_data = pd.read_csv(f"{prefix_path}VN30F2M_data.csv")
        f2_data = f2_data[["date", "datetime", "tickersymbol", "price", "close"]].copy()
        f2_data["datetime"] = pd.to_datetime(
            f2_data["datetime"], format="%Y-%m-%d %H:%M:%S.%f"
        )
        f2_data["date"] = (
            pd.to_datetime(f2_data["date"], format="%Y-%m-%d").copy().dt.date
        )
        f2_data.rename(
            columns={
                "price": "f2_price",
                "close": "f2_close",
                "tickersymbol": "f2-tickersymbol",
            },
            inplace=True,
        )
        rounding_columns = ["f2_close", "f2_price"]
        for col in rounding_columns:
            f2_data = round_decimal(f2_data, col)

        f1_data = pd.merge(
            f1_data,
            f2_data,
            on=["datetime", "date"],
            how="outer",
            sort=True,
        )
        f1_data = f1_data.ffill()
        return f1_data

    # ------------------------------------------------------------------
    # Main run loop
    # ------------------------------------------------------------------

    def run(self, data: pd.DataFrame, step: Decimal = Decimal('0.1')):
        """
        Iterate tick-by-tick through `data` and apply the SMA(1000) crossover strategy.

        `step` is kept as a parameter for API compatibility but is not used by this
        strategy (the limit-order price offset is 1 tick = 0.1 index point by convention).
        """
        trading_dates = data["date"].unique().tolist()

        start_date = data["datetime"].iloc[0]
        end_date   = data["datetime"].iloc[-1]
        expiration_dates = get_expired_dates(start_date, end_date)

        cur_index    = 0
        moving_to_f2 = False

        for index, row in data.iterrows():
            # ---- select the active contract price ----
            tick_price  = row["f2_price"] if moving_to_f2 else row["price"]
            close_price = row["f2_close"] if moving_to_f2 else row["close"]

            # ---- roll over F1 → F2 on expiry week ----
            if (
                cur_index != len(trading_dates) - 1
                and not expiration_dates.empty()
                and trading_dates[cur_index + 1] >= expiration_dates.queue[0]
            ):
                expiration_dates.get()
                moving_to_f2 = True

            # ---- update rolling SMA window ----
            self._price_window.append(tick_price)
            cur_sma = self._current_sma()

            # ---- generate crossover signals (only when SMA is available) ----
            if cur_sma is not None and self._prev_price is not None and self._prev_sma is not None:
                prev_price = self._prev_price
                prev_sma   = self._prev_sma

                # --- check TP / SL on existing position first ---
                if self.inventory != 0:
                    upnl = self._unrealised_pnl(tick_price)
                    if upnl >= TP_POINTS * MULTIPLIER or upnl <= -SL_POINTS * MULTIPLIER:
                        self._close_position(tick_price)

                # --- crossover signal: open (or flip) position ---
                if self.inventory == 0:
                    # Buy signal: prev < SMA and cur >= SMA
                    if prev_price < prev_sma and tick_price >= cur_sma:
                        self._open_position(+1, tick_price)
                    # Sell signal: prev > SMA and cur <= SMA
                    elif prev_price > prev_sma and tick_price <= cur_sma:
                        self._open_position(-1, tick_price)

            # ---- store previous-tick values for next iteration ----
            self._prev_price = tick_price
            self._prev_sma   = cur_sma

            # ---- end-of-day bookkeeping ----
            is_last_tick_of_day = (
                index == len(data) - 1
                or row["date"] != data.iloc[index + 1]["date"]
            )
            if is_last_tick_of_day:
                # Force-close any open position at today's close (overnight rule)
                self._update_pnl(close_price)

                if self.printable:
                    print(
                        f"Realized asset {row['date']}: "
                        f"{int(self.daily_assets[-1] * Decimal('1000'))} VND"
                    )

                if moving_to_f2:
                    self.monthly_tracking.append([row["date"], self.daily_assets[-1]])

                self.tracking_dates.append(row["date"])
                self.daily_inventory.append(self.inventory)

                # reset daily counters
                moving_to_f2 = False
                self._prev_price = None
                self._prev_sma   = None
                self._price_window.clear()
                cur_index += 1

        self.metric = Metric(self.daily_returns, None)

    def plot_hpr(self, path="result/backtest/hpr.svg"):
        """
        Plot and save NAV chart to path

        Args:
            path (str, optional): _description_. Defaults to "result/backtest/hpr.svg".
        """
        plt.figure(figsize=(10, 6))

        assets = pd.Series(self.daily_assets)
        ac_return = assets.apply(lambda x: x / assets.iloc[0])
        ac_return = [(val - 1) * 100 for val in ac_return.to_numpy()[1:]]
        plt.plot(
            self.tracking_dates,
            ac_return,
            label="Portfolio",
            color='black',
        )

        plt.title('Holding Period Return Over Time')
        plt.xlabel('Time Step')
        plt.ylabel('Holding Period Return (%)')
        plt.grid(True)
        plt.legend()
        plt.savefig(path, dpi=300, bbox_inches='tight')

    def plot_drawdown(self, path="result/backtest/drawdown.svg"):
        """
        Plot and save drawdown chart to path

        Args:
            path (str, optional): _description_. Defaults to "result/backtest/drawdown.svg".
        """
        _, drawdowns = self.metric.maximum_drawdown()

        plt.figure(figsize=(10, 6))
        plt.plot(
            self.tracking_dates,
            drawdowns,
            label="Portfolio",
            color='black',
        )

        plt.title('Draw down Value Over Time')
        plt.xlabel('Time Step')
        plt.ylabel('Percentage')
        plt.grid(True)
        plt.savefig(path, dpi=300, bbox_inches='tight')

    def plot_inventory(self, path="result/backtest/inventory.svg"):
        plt.figure(figsize=(10, 6))
        plt.plot(
            self.tracking_dates,
            self.daily_inventory,
            label="Portfolio",
            color='black',
        )

        plt.title('Inventory Value Over Time')
        plt.xlabel('Time Step')
        plt.grid(True)
        plt.tight_layout()
        plt.savefig(path, dpi=300, bbox_inches='tight')


if __name__ == "__main__":
    bt = Backtesting(
        capital=Decimal("5e5"),
    )

    data = bt.process_data()
    bt.run(data)   # step param not used by SMA crossover strategy

    print(
        f"Sharpe ratio: {bt.metric.sharpe_ratio(risk_free_return=Decimal('0.00023')) * Decimal(np.sqrt(250))}"
    )
    print(
        f"Sortino ratio: {bt.metric.sortino_ratio(risk_free_return=Decimal('0.00023')) * Decimal(np.sqrt(250))}"
    )
    mdd, _ = bt.metric.maximum_drawdown()
    print(f"Maximum drawdown: {mdd}")

    monthly_df = pd.DataFrame(bt.monthly_tracking, columns=["date", "asset"])
    returns = get_returns(monthly_df)

    print(f"HPR {bt.metric.hpr()}")
    print(f"Monthly return {returns['monthly_return']}")
    print(f"Annual return {returns['annual_return']}")

    bt.plot_hpr()
    bt.plot_drawdown()
    bt.plot_inventory()
